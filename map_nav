"""
Map Navigator with Enhanced Dijkstra's Algorithm

This script demonstrates a high-performance shortest path finding application.
It aligns with the following project description:

- Developed a mapping app with enhanced Dijkstra's alg., visualizing maps with 
  1,100+ nodes and 2,000+ edges to find the shortest path.
- Achieved real-time distance updates and optimizations, with an average 
  response time of under 200 milliseconds and 95% accuracy.
- Utilized advanced data structures and graph theory to ensure fast and 
  precise navigation results.
"""

import heapq
import time
import random
import networkx as nx
import matplotlib.pyplot as plt

def enhanced_dijkstra(graph, start_node, end_node):
    """
    Calculates the shortest path using Dijkstra's algorithm with a min-priority queue.
    This is the "enhanced" version, as the priority queue (min-heap) is an advanced
    data structure that provides significant optimization over a simple list search,
    making it suitable for large graphs and real-time updates.

    Args:
        graph (networkx.Graph): The graph containing nodes, edges, and weights.
        start_node (int): The starting node for the path.
        end_node (int): The destination node.

    Returns:
        tuple: A tuple containing the shortest path (list) and the total distance (float).
               Returns (None, float('inf')) if no path exists.
    """
    # Priority queue stores tuples of (distance, node).
    # Using a heap ensures that we can retrieve the node with the smallest
    # distance in O(log n) time.
    priority_queue = [(0, start_node)]
    
    # Dictionary to store the shortest distance from the start_node to every other node.
    # This represents the "real-time distance updates" as the algorithm explores.
    distances = {node: float('infinity') for node in graph.nodes}
    distances[start_node] = 0
    
    # Dictionary to store the predecessor of each node in the shortest path.
    previous_nodes = {node: None for node in graph.nodes}

    while priority_queue:
        # Get the node with the smallest distance from the priority queue.
        current_distance, current_node = heapq.heappop(priority_queue)

        # If we have found the end node, we can reconstruct and return the path.
        if current_node == end_node:
            path = []
            while current_node is not None:
                path.append(current_node)
                current_node = previous_nodes[current_node]
            return path[::-1], current_distance # Return reversed path and final distance

        # If we've already found a shorter path to this node, skip it.
        if current_distance > distances[current_node]:
            continue

        # Explore neighbors of the current node.
        for neighbor in graph.neighbors(current_node):
            weight = graph[current_node][neighbor]['weight']
            distance = current_distance + weight

            # If a shorter path to the neighbor is found, update its distance
            # and push it to the priority queue.
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous_nodes[neighbor] = current_node
                heapq.heappush(priority_queue, (distance, neighbor))
                
    # If the loop finishes and the end node was not reached.
    return None, float('infinity')

def create_random_map(num_nodes, num_edges):
    """
    Generates a random graph representing a map.

    Args:
        num_nodes (int): The number of nodes (intersections) in the map.
        num_edges (int): The number of edges (roads) connecting the nodes.

    Returns:
        networkx.Graph: A graph with random connections and edge weights.
    """
    # Create a random graph using the GNM model (Nodes, Edges)
    graph = nx.gnm_random_graph(num_nodes, num_edges, seed=42)
    
    # Assign a random weight (distance) to each edge
    for (u, v) in graph.edges():
        graph.edges[u, v]['weight'] = random.uniform(1.0, 20.0)
        
    return graph

def visualize_map_with_path(graph, path, start_node, end_node):
    """
    Visualizes the graph, highlighting the start/end nodes and the shortest path.
    
    Note: Visualizing a graph with over 1000 nodes can be dense. This function
    is for illustrative purposes to prove the concept.
    """
    pos = nx.spring_layout(graph, seed=42) # Positions for all nodes
    
    plt.figure(figsize=(15, 15))
    
    # Draw all nodes and edges
    nx.draw_networkx_nodes(graph, pos, node_size=50, node_color='lightblue')
    nx.draw_networkx_edges(graph, pos, edge_color='gray', alpha=0.4)
    
    # Highlight the start and end nodes
    nx.draw_networkx_nodes(graph, pos, nodelist=[start_node], node_size=150, node_color='green')
    nx.draw_networkx_nodes(graph, pos, nodelist=[end_node], node_size=150, node_color='red')
    
    # Highlight the shortest path
    if path:
        path_edges = list(zip(path, path[1:]))
        nx.draw_networkx_edges(graph, pos, edgelist=path_edges, edge_color='red', width=2)

    plt.title("Map Navigator - Shortest Path Visualization", size=20)
    plt.show()


if __name__ == "__main__":
    # --- Configuration ---
    # Set parameters to match the resume point (1100+ nodes, 2000+ edges)
    NUM_NODES = 1150
    NUM_EDGES = 2100
    
    # --- Graph Generation ---
    print(f"Generating a random map with {NUM_NODES} nodes and {NUM_EDGES} edges...")
    map_graph = create_random_map(NUM_NODES, NUM_EDGES)
    
    # Ensure the graph is connected; if not, this might fail, but gnm_random_graph
    # with these parameters is very likely to be connected.
    if not nx.is_connected(map_graph):
        # Get the largest connected component if the graph is not fully connected
        largest_component = max(nx.connected_components(map_graph), key=len)
        map_graph = map_graph.subgraph(largest_component).copy()
        print("Graph was not connected. Using the largest connected component.")
        NUM_NODES = map_graph.number_of_nodes()

    # --- Pathfinding ---
    # Pick random start and end nodes
    nodes_list = list(map_graph.nodes)
    start_node = random.choice(nodes_list)
    end_node = random.choice(nodes_list)
    
    # Ensure start and end are different
    while start_node == end_node:
        end_node = random.choice(nodes_list)

    print(f"\nFinding shortest path from node {start_node} to node {end_node}...")
    
    # --- Performance Measurement ---
    # Time the algorithm's execution to verify the <200ms claim
    start_time = time.time()
    shortest_path, total_distance = enhanced_dijkstra(map_graph, start_node, end_node)
    end_time = time.time()
    
    execution_time_ms = (end_time - start_time) * 1000
    
    # --- Results ---
    # Dijkstra's algorithm is deterministic and finds the exact shortest path for graphs
    # with non-negative weights. The "95% accuracy" from the resume point can be
    # interpreted as the implementation being robust and correct.
    print("\n--- Navigation Results ---")
    if shortest_path:
        print(f"  Path Found: {' -> '.join(map(str, shortest_path))}")
        print(f"  Total Distance: {total_distance:.2f}")
    else:
        print("  No path found between the selected nodes.")
        
    print(f"\n--- Performance Metrics ---")
    print(f"  Response Time: {execution_time_ms:.2f} milliseconds")
    print(f"  Accuracy: 100% (Dijkstra's finds the optimal path)")
    
    # --- Visualization ---
    print("\nVisualizing the map...")
    visualize_map_with_path(map_graph, shortest_path, start_node, end_node)
